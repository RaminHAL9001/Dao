TODO:
* Fix this design flaw:
	The abstract syntax tree can produce expressions that cannot be parsed. For example,
	'Dao.Object.AST.AST_Prefix' contains an arbitrary (commented) 'Dao.Object.AST.AST_Object'
	expression, but the parser does not allow arbitrary expressions to be parsed after a prefix
	operator (the prefix operators are "$", "@", ".", "~", "-", "!"). This simplifies the abstract
	syntax tree. The "Dao.Evaluator" module should have no problem evaluating expressions regardless
	of whether or not the syntax of the language can construct these expressions.  But might cause
	problems if the abstract syntax tree is produced programmatically for example, using the
	functions in the "Dao.Struct" or "Dao.Random" modules, and then that abstract syntax tree is
	used to generate code, the code generated will not be parsable. I have corrected the
	"Dao.Object.Random" module so that this is not a problem, but this could cause problems with
	"Dao.Object.Struct". For now, the AST is simplified and I would prefer it to stay that way, even
	if it is not modeled well enough to prevent potential problems like this one.

* Unioning 'Dao.Enum.SetM' data types should produce a list of segments where not every item is
	associated with the same return value. I will need to modify the 'Dao.EnumSet.SetM' data type to
	have a fifth constructor 'MultiSet' which contains a list of pairs of the type:
		('Dao.EnumSet.Segment c', x)
	where @x@ is the return value contained within constructor. Unioning sets should work a bit more
	like 'Prelude.concatMap' does when a list is treated as a monad. However intersecting
	'Dao.EnumSet.SetM' types is the operation to be used for monadic bind.

* Fix the bugs introduced into the "Dao.EnumSet" module after this last bout of sweeping changes.

* Complex numbers are not being parsed correctly by the new parser.

*	Try to make the new parser more efficient. Here is the results from the old parser:
	576 tests completed at the rate of 144.00 tests per second
	1036 tests completed at the rate of 115.00 tests per second
	1515 tests completed at the rate of 119.75 tests per second
	1974 tests completed at the rate of 114.75 tests per second
	2507 tests completed at the rate of 133.25 tests per second
	3026 tests completed at the rate of 129.75 tests per second
	3488 tests completed at the rate of 115.50 tests per second
	3966 tests completed at the rate of 119.50 tests per second
	4436 tests completed at the rate of 117.50 tests per second
	4922 tests completed at the rate of 121.50 tests per second
	5383 tests completed at the rate of 115.25 tests per second
	5911 tests completed at the rate of 132.00 tests per second

*	Bug: item number 147555 generated by the random object generator seems to be resulting in either
an infinite loop, or an inordinate amount of memory consumption.

*	Bug: the instantiation for many of the nodes in the "Dao.Object.AST" module for
'Dao.Struct.fromStruct' are not correctly constructing AST nodes with comments. This might be
related to the above bug.

*	Now that 'Dao.Predicate.PValue' has been modified such that it no longer contains a required
'Dao.String.UStr' message, many functions which used it now simply use 'Dao.String.UStr' as the type
for 'Dao.Predicate.PFail'. Other functions do not use 'Dao.String.UStr'. I need to do a review of
all code in the "Dao.Evaluator" module that makes use of 'Dao.Predicate.PValue' and make sure the
failures contain useful information. If a 'Dao.String.UStr' is good enough, no change will be
necessary. However it might be better to use 'Dao.Object.Object' instead, in most situations.

*	Really need to modify the parser so variable scoping is parsed with a higher presecedence than
arithmetic or assignment operators. As of right now, expressions do not parse as one would expect. I
can work around this issue by putting parentheses around qualified variables:
	global a = 1;   // Fails, parses as global (a = 1);
	(global a) = 1; // Success.

*	Need to introduce constructors for 'Dao.EnumSet.EnumSet' and 'Dao.Object.Pattern' into the
'Dao.Object.Object' data type.

*	Clean up the "Dao.Parser" module.

*	Parse each input file in a separate thread, deep-sequence the parsed structures.

*	Listable parsers that end in a comma on their last item, with the comma followed by a closing
brace instead of another item, will return a null list. This should not happen.

*	Need to change "Dao.Parser", eliminate the 'Dao.Parser.Regex' data type and make the parser
comibators themselves a datatype. There needs to be a metric for sorting how strict a regular
expression is, with /.*/ being the least strict (matches anything), and long strings of characters
being most strict (the longer, the more strict they are), and when parsers choices are summed using
'Control.Monad.mplus', the choices are sorted from greatest to least strict and applied in that
order.

*	Some inlining pretty-printers are still messing up the indentation.

*	Need to create a means to track which modules have "open()"-ed and "close()"-ed which files. Like
reference counting with sets, each file will have a set of module references with an element for
every module that has "open()"-ed it without yet "close()"-ing it. Files loaded from the command
line might be represented by "Nothing" where files loaded by a module migh be represented by
"Just moduleName".

*	Implement the "editSource()" built-in function for loading Dao scripts into memory and allowing
the abstract syntax tree to be modified. There need to be editor functions, like "updateWith()",
which takes a source function and a lambda that traverses the AST and replaces matching nodes with a
returned value. There should also be a "testSource()" built-in function for evaluating an edited
source code into a working module object, and executing strings against that, all done so
programmatically within the running Dao program.

*	'Dao.Object.Subroutine' is a data structure representing a function that takes a list of
'Dao.Object.ObjPat's, and when it is executed, it will resolve all Reference parameters passed to
them to create a list of parameters, match this list of parameter arguments to this list of
'Dao.Object.ObjPat's, then run the associated 'Dao.Object.Executable'.
	It might be a good idea to allow other kinds of 'Subroutine's, including "pure" subroutines that
simply evaluate to (CEError Object), functions take a list of Objects that do not automatically
resolve references passed to them. Since built-in operators are pure subroutines, an API for
evaluating these operator functions could be constructed to evaluate both built-in operators and
custom native functions. Also, right now the evaluator checks if an operator is an assignment or
update operator, and treats these as special cases. However, if there is a "pure" subroutine that
takes parameters that are not resolved automatically, the update operators can be defined as
object instances of this type of "pure" subroutine.
	Because the 'ObjPat's (now called 'Pattern's) are matched in a pure function,
there is no way to indicate whether or not you want to match the pattern against a reference or the
value to which the reference is pointing like in C++. The pattern matching function needs to be
lifted into IO so that dereferencing is possible, and there needs to be a separate pattern for
matching values of referenecs, which needs to be the default pattern that binds values to labels.

SOLVED:

* TODO AFTER the new parser is fully functioning and the old parser has been deleted:
the "Dao.EnumSet" exposes many functions for manipulating 'Dao.EnumSet.Segment's. I would like to
keep 'Dao.EnumSet.Segment' exposed, but have all of the functions which manipulate it directly
(apart from it's constructor) to no longer be exported, and instead make everything which imoprts
the "Dao.EnumSet" module make use of the 'Dao.EnumSet.EnumSet' data type exclusively.
[Solution] It turns out I needed it sooner rather than later. So I just went ahead and changed
everything in the "Dao.EnumSet" module, and then I had to go through the old parser modules,
refactoring everything that broke. I would like to re-affirm my love of Haskell's propensity for
finding errors, and my love of the old UNIX "Sed" program, which in spite of all its primitive
simplicity, still happens to be extremely useful for refactoring.

*	There is an infinite loop in the "Dao.Struct" module caused on certain occasions where the
'Dao.Struct.atAddress' is called. I've tracked the problem down to 'Dao.Object.AST.AST_Assign'
expressions, although I am still not clear as to why it is looping infinitely.
[Solution] it was actually a problem with the instantiation of 'Dao.Token.Location' into the
'Dao.Structured.Struct' monad. It evaluated 'Dao.Struct.getData' in a place where it should have
evaluated 'Dao.Struct.getDataAt', which was causing it to call a function that would eventually call
itself wihtout ever stepping into a field of a sub-structure.

*	Need to implement the evaluator for the "meta-dereference" operator, and make sure it is placed
in the 'Dao.Evaluator.setupExecutable' function.

*	Change the 'evalObjectExpr' function so it always returns a location, it's type should be:
@evalObjectExpr :: ObjectExpr -> Exec (Location, Maybe Object)@
Then if it ever incorrectly evaluates to a pair where the second value is 'Nothing', the location
can still be used to report where the failed evaluation occurs.
[Solution] It wasn't challenging but it was tedius, and I've now made it work exactly as described.

*	Need to change the types of @'Dao.Object.Exec' a@ and 'Dao.Object.Run' so they can more easily
be evaluated with one-another.
[Solution] I already did this a while ago, I forgot about it.

*	Break the abstract syntax tree off into it's own module, keeing the byte-code-like object as
part of the "Dao.Object" module.
[Solution] The abstract syntax tree I was using before has been copied into the "Dao.Object.AST"
module and every data type and constructor has been renamed to have the @AST_@ prefix, with the
suffix "Expr" removed from many of the constrcutors to shorten the name. The original names for the
data types and constructors have been kept in the "Dao.Object" module, but these data types and
constructors now have a different type: the comments have been removed, and thus these old names now
refer to a new "Intermediate" data type. There is an 'Dao.Object.AST.Intermediate' class in the
"Dao.Object.Intermediate" module which uses functional dependencies to associate the intermedaite
types with the abstract syntax tree types, and this class provides methods for converting between
these types ('Dao.Object.AST.toInterm' and 'Dao.Object.AST.fromInterm'). The evaluator and
binary serialization now make use the intermediate types. The pretty printer, random object
generator, the "Dao.Struct" interface, and the parser make use of the "Dao.Object.AST" types. Where
an intermediate structure needs to be treated as an abstract syntax tree, for example in the
instantiation of the intermediate type into the pretty printer class, the intermediate type is
simply converted to it's abstract syntax tree form using 'Dao.Object.AST.fromInterm' and the
instantiation for the abstract syntax tree is then called.

*	Need a class for converting data types to 'Dao.Tree.Tree's, with functions like "dataToStruct" and
"structToData". Also in this module, there should be a State monad for building trees and updating
trees, preferably a state that lifts the 'PValue' monad so you can throw errors.
[Solution] This is the "Dao.Struct" and "Dao.Object.Struct" modules.

*	Need a new element of the abstract syntax tree for parsing 'Dao.Object.Pattern's.
[Soltuion] This will be done with the function call notation, or with the "Dao.Struct" interface.

*	Allow "catch" statements in the top level, which are a LambdaExprType expression that only
respond to uncaught errors. Modify the "catch" statement to allow pattern expressions that only
catch errors that match.

*	Rename "Dao.Object.Show" to "Dao.Object.PPrint". [Done]

*	Rename 'Dao.Glob.PatUnit' to 'GlobUnit'. [Done]

*	Need to provide a "meta-dereference" operator (kind of like macros in the C preprocessor) for
constant script and rule object declarations in code. These objects treat all references as unbound.
Binding values are only resolved when the script code is evaluated, even if the context of variables
is completely different from the time it was defined at the time it is evaluated. It might be handy
to programmers if they had a means to tell Dao to "replace the variable name in this line of code
with the value the variable has right now, and construct the script or rule object with that value
instead of a reference in that point in the abstract syntax tree."
[Solution] the data type is there, but it has still not been implemented in the "Dao.Evaluator".

*	Need to define a second rule table for rules that respond to 'Dao.Object.ObjPat's.
Completed: this is called 'patternTable' and is a list of patterns in an 'Dao.Object.ExecUnit'.

*	Need a parser for "Dao.Object.ObjPat". Rename 'Dao.Pattern.Pattern' to "Dao.Glob.Glob' and
rename 'Dao.Object.ObjPat' to 'Dao.Object.Pattern'.
	I have decided that the word 'Glob' is a better term for what I was calling a 'Pattern'. A glob
is an old idea from UNIX where you can match arbitrary strings with wildcards, like writing "*.hs"
in the command line and the command line automatically detects the "*" as a wildcard and expands the
word to the list of all files matching the glob expression. This is in fact the very idea that
inspired my 'Pattern' data type. But the word 'Pattern' was too general, so why not just call it a
'Glob'? So that is what I have done.

*	Investigate the pathalogical memory usage of the random test generator and parser.
	SOLUTION: I will never use 'Control.Concurrent.Chan.Chan' ever again. I was generating integer
values and passing them down a channel to several worker threads which would then take these
integers from the channel and use them to generate random objects for testing the parser and
serializer. Obviously the thread producing these integer values would run faster than the worker
threads. What I didn't know was that channels will never block a 'writeChan' operation, and they
have no limit on the number of items they can buffer, which means the integer generating thread
which was designed to generate integers non-stop, would fill the channel, and the channel would
buffer them until all memory was used up and the kernel killed the process. There must some some
reason channel to have these properties, but I think it is just stupid.

*	Need to modify the parser test program to generate entire source files, not just individual
object expressions, so the whole parser can be tested.

*	The "Dao.Object.Show" module is dreadfully out of date, it needs to be cleaned up for all the
changes made to the abstract syntax tree.

*	Re-write most of "Dao.Object.Binary". There needs to be a way to define the byte-prefix of
important object nodes using Haskell. Right now I am doing it by hand with case statements, and I
need to go and change everything by hand (introducing many errors) every time I modify the abstract
syntax tree. Once Dao version 1.0 is released, I can freeze the instantiation of "Dao.Object" into
the Binary class, but until then there is too much flux in the code.
	COMPLETION NOTE: turns out I didn't need to completely rewrite it, but it did need a lot of
cleaning up. I would like to, someday, instantiate the entire abstract syntax tree into the
'Data.Data.Data' class, and make use of generic functions like "gfoldl" and "gmapM" to define the
serialization coder/decoders, parsers, and pretty printers, but that may never happen.

*	Need to implement the "while" statement.

*	Need to left-factor the 'Dao.Object.Parser.parseDirective' parsers.

*	There seems to be a bug with the 'Dao.Objcet.IfThenElse' branch of the abstract syntax tree. I
	am having difficulty getting if expressions to evaluate correctly.
	For the 'Dao.Object.ObjectExpr' instantiation of 'HasLocation', I forgot to write a pattern for
	the 'Dao.Object.PrefixExpr' data constructor in the case statement, and Haskell found a way to
	evaluate the 'Dao.Object.ObjectExpr' without evaluating that case statement which involved
	entirely ignoring the evaluation of the Dao script "if" statement, which is not what I expected
	to happen. The correct behavior (what I was expecting) was evaluation of any
	'Dao.Object.ObjectExpr' would necessarily evaluate the entire expression, however it seems I
	have not defined my progam in such a way that this will happen. I might need to make the
	evaluator a bit more strict.

