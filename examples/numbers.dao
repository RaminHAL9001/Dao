BEGIN { global no_match = true; }

function wordSet($SET, words) {
	set = @SET;
	println("wordSet(", SET, "::", typeof(set), ", ", words, ")");
	try{ return local set.do(join("", words)); } catch err{ println("ERROR: ", err); }
	println("(backtrack)");
	throw;
}

function Numeral(x) { try { return int(join("", x)); } else {} catch err {} }

//--------------------------------------------------------------------------------------------------

function Digit(words) { return global wordSet(global digitSet, words); }
digitSet = RuleSet {
	rule "zero" {return 0;}, rule "a"    {return 1;}, rule "one"  {return 1;},
	rule "two"  {return 2;}, rule "three"{return 3;}, rule "four" {return 4;},
	rule "five" {return 5;}, rule "six"  {return 6;}, rule "seven"{return 7;},
	rule "eight"{return 8;}, rule "nine" {return 9;},
	rule "$x::Numeral?" { try{ x=int(join("",x)); if(x<999) {return x;} } catch err{} throw; }
};


function Umpteen(words) { return global wordSet(global umpteenSet, words); }
umpteenSet = RuleSet {
	rule "ten"      {return 10;},
	rule "eleven"   {return 11;}, rule "twelve"  {return 12;}, rule "thirteen"{return 13;},
	rule "fourteen" {return 14;}, rule "fifteen" {return 15;}, rule "sixteen" {return 16;},
	rule "seventeen"{return 17;}, rule "eighteen"{return 18;}, rule "nineteen"{return 19;}
};

function Umpty(words) { return dictWord(global umptySet, words); }
umptySet = dict {
	rule "twenty" {return 20;}, rule "thirty"{return 30;}, rule "fourty" {return 40;},
	rule "fifty"  {return 50;}, rule "sixty" {return 60;}, rule "seventy"{return 70;},
	rule "eighty" {return 80;}, rule "ninety"{return 90;}
};

function Illion(words) { return dictWord(global illionSet, words); }
illionSet = RuleSet {
	rule "thousand"          { return 10**3; },
	rule "million"           { return 10**6; },
	rule "billion"           { return 10**9; },
	rule "trillion"          { return 10**12; },
	rule "quadrillion"       { return 10**15; },
	rule "quintillion"       { return 10**18; },
	rule "sextillion"        { return 10**21; },
	rule "setptillion"       { return 10**24; },
	rule "octillion"         { return 10L**27; },
	rule "nonillion"         { return 10L**30; },
	rule "decillion"         { return 10L**33; },
	rule "undecillion"       { return 10L**36; },
	rule "dodecillion"       { return 10L**39; },
	rule "tredecillion"      { return 10L**42; },
	rule "quattuordecillion" { return 10L**45; },
	rule "quinquadecillion"  { return 10L**48; },
	rule "sexdecillion"      { return 10L**51; },
	rule "septdecillion"     { return 10L**54; },
	rule "octdecillion"      { return 10L**57; },
	rule "novendecillion"    { return 10L**60; },
	rule "vigintillion"      { return 10L**63; }
};

function Hundred(words) { return global wordSet(global hundredSet, words); }
hundredSet = RuleSet {
	rule "hundred" { return null; },
	rule("hundred $H", "hundred and $H") { return H; }
};

function multIllion(d, words) {
	if(words) {
		try{
			p = global multIllionSet.do(words);
			return global subThousand(d*p.fst, p.snd);
		}
		else{}
	}
	return Pair(d, words);
}
multIllionSet = RuleSet {
	rule "$i::Illion?" { return Pair(i, null); },
	rule "$i::Illion? $X" { return Pair(i, X); }
};

function subHundred(h, words) {
	if(words) {
		try{
			p = global subHundredSet.do(words);
			return global multIllion(h+p.fst, p.snd);
		}
		else{}
	}
	return Pair(h, words);
}
subHundredSet = RuleSet {
	rule("$d::Digit?",    "$d::Umpteen?",    "$d::Umpty?"   )    { return Pair(d, null); },
	rule("$d::Digit? $X", "$d::Umpteen? $X", "$d::Umpty? $X")    { return Pair(d, X); },
	rule("$u::Umpty? $d::Digit?", "$u::Umpty?-$d::Digit?")       { return Pair(u+d, null); },
	rule("$u::Umpty? $d::Digit? $X", "$u::Umpty?-$d::Digit? $X") { return Pair(u+d, X); }
};

function SubThousand(words) { return global wordSet(global subThousandSet, words); }
subThousandSet = RuleSet {
	rule "$d::Digit?" { return Pair(d, null); },
	rule "$d::Digit? $H::Hundred" { return global subHundred(d*100, H); }
};

function Number(words) { return global wordSet(global numberSet, words); }
numberSet = RuleSet {
	rule "$n::SubThousand" { return n; },
	rule("negative $n::SubThousand", "minus $n::SubThousand") { return Pair(-n.fst, n.snd); }
};

rule "$n::Number" {
	if(n.snd) { println(n.fst, " ", join("", n.snd)); }
	else { println(n.fst); }
	return n;
}

