// "examples/numbers.dao"  this is a demo program written in the Dao
// programming lagnuage that will convert numbers expressed as English
// language to integers.
// 
// Copyright (C) 2008-2014  Ramin Honary.
// This file is part of the Dao System.
//
// The Dao System is free software: you can redistribute it and/or
// modify it under the terms of the GNU General Public License as
// published by the Free Software Foundation, either version 3 of the
// License, or (at your option) any later version.
// 
// The Dao System is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program (see the file called "LICENSE"). If not, see
// <http://www.gnu.org/licenses/agpl.html>.

//--------------------------------------------------------------------------------------------------
// I have written this program with efficiency in mind. Every variable reference is qualified.

DEBUG = false;
BEGIN { global no_match = true; }
rule("show work", "verbose") {
	global DEBUG = true; global no_match = false;
	const println("will think out loud");
}
rule("quiet", "silent") {
	global DEBUG = false; global no_match = false;
	const println("will think quietly");
}

global tab = list{};
function wordSet($SET, words) {
	local set = @SET;
	local tab = "";
	if(global DEBUG) {
		local tab = join("", global tab);
		global tab = global tab + list{"  "};
		const println(local tab, "wordSet(", local SET, "::", const typeof(local set), ", ", local words, ")");
	}
	try{ local x = local set.do(local words); global tab <<= 1; return local x; }
	else{} catch err{ const println(local err); }
	if(global DEBUG) { const println(local tab, "BACKTRACK"); }
	global tab <<= 1;
	throw;
}

//--------------------------------------------------------------------------------------------------

function Numeral(x) {
	try{ return const int(const join("", x)); }
	else{} catch err{} throw;
}

function Digit(words) { return global wordSet(global digitSet, words); }
digitSet = RuleSet {
	rule "zero" {return 0;}, rule "a"    {return 1;}, rule "one"  {return 1;},
	rule "two"  {return 2;}, rule "three"{return 3;}, rule "four" {return 4;},
	rule "five" {return 5;}, rule "six"  {return 6;}, rule "seven"{return 7;},
	rule "eight"{return 8;}, rule "nine" {return 9;},
	rule "$x::Numeral?" { try{ x=int(join("",x)); if(x<999) {return x;} } catch err{} throw; }
};

function Umpteen(words) { return global wordSet(global umpteenSet, words); }
umpteenSet = RuleSet {
	rule "ten"      {return 10;},
	rule "eleven"   {return 11;}, rule "twelve"  {return 12;}, rule "thirteen"{return 13;},
	rule "fourteen" {return 14;}, rule "fifteen" {return 15;}, rule "sixteen" {return 16;},
	rule "seventeen"{return 17;}, rule "eighteen"{return 18;}, rule "nineteen"{return 19;}
};

function SubTwenty(words) { return global wordSet(global subTwentySet, words); }
subTwentySet = umpteenSet | digitSet;

function Umpty(words) { return wordSet(global umptySet, words); }
umptySet = RuleSet {
	rule "twenty" {return 20;}, rule "thirty"{return 30;}, rule "fourty" {return 40;},
	rule "fifty"  {return 50;}, rule "sixty" {return 60;}, rule "seventy"{return 70;},
	rule "eighty" {return 80;}, rule "ninety"{return 90;}
};

function Illion(words) { return wordSet(global illionSet, words); }
illionSet = RuleSet {
	rule "thousand"          { return 10**3; },
	rule "million"           { return 10**6; },
	rule "billion"           { return 10**9; },
	rule "trillion"          { return 10**12; },
	rule "quadrillion"       { return 10**15; },
	rule "quintillion"       { return 10L**18; },
	rule "sextillion"        { return 10L**21; },
	rule "septillion"        { return 10L**24; },
	rule "octillion"         { return 10L**27; },
	rule "nonillion"         { return 10L**30; },
	rule "decillion"         { return 10L**33; },
	rule "undecillion"       { return 10L**36; },
	rule "dodecillion"       { return 10L**39; },
	rule "tredecillion"      { return 10L**42; },
	rule "quattuordecillion" { return 10L**45; },
	rule "quinquadecillion"  { return 10L**48; },
	rule "sexdecillion"      { return 10L**51; },
	rule "septdecillion"     { return 10L**54; },
	rule "octdecillion"      { return 10L**57; },
	rule "novendecillion"    { return 10L**60; },
	rule "vigintillion"      { return 10L**63; }
};

function AnyNumberWord(words) { try{ global anyNumberWordSet.do(words); return words; } catch err{ println(err); } }
anyNumberWordSet = global subTwentySet | global umptySet | global illionSet | RuleSet {
	rule "hundred" { return 100; }, rule("negative", "minus") { return -1; }
};

function splitNumberWords(w) {
	local accum = list{};
	local breaker = false;
	while(local w) {
		try{
			local p = global splitNumberWordsSet.do(local w);
			local accum = const concat(local accum, local p.fst);
			local w = local p.snd;
		}
		else{ local breaker = true; }
		catch err{ println(err); local breaker = true; }
		if(breaker) { return Pair(local accum, local w); }
	}
	return Pair(local accum, local w);
}
splitNumberWordsSet = RuleSet {
	rule "" { return Pair(list{}, list{}); },
	rule "$a::AnyNumberWord?" {
		return Pair(list{local a}, list{});
	},
	rule("$a::AnyNumberWord? $b", "$a::AnyNumberWord?-$b") {
		return Pair(list{local a, " "}, local b);
	},
	rule("$a::AnyNumberWord?, $b", "$a::AnyNumberWord?$b") {
		return Pair(list{local a, " "}, local b);
	},
	rule( "$a::AnyNumberWord? and $b", "$a::AnyNumberWord?-and-$b"
		, "$a::AnyNumberWord?-and $b", "$a::AnyNumberWord? and-$b") {
		return Pair(list{local a, " ", "and", " "}, local b);
	}
};

function SubHundred(words) { return global wordSet(global subHundredSet, words); }
subHundredSet = RuleSet {
	rule("$d::Digit?", "$d::Umpteen?", "$d::Umpty?") { return local d; },
	rule "$u::Umpty? $d::Digit?" { return local u + local d; }
};

function SubThousand(words) { return global wordSet(global subThousandSet, local words); }
subThousandSet = RuleSet {
	rule "hundred" { return 100; },
	rule "$h::SubHundred hundred" { return local h * 100; },
	rule("$h::SubHundred hundred $n::SubHundred", "$h::SubHundred hundred and $n::SubHundred") {
		return local h * 100 + local n;
	},
	rule "$h::SubHundred" { return local h; },
	rule "$d::SubTwenty? hundred" { return local d*100; },
	rule("$d::SubTwenty? hundred $h::SubHundred",
		 "$d::SubTwenty? hundred and $h::SubHundred") { return local d*100 + local h; }
};

function Natural(words) { return global wordSet(global naturalSet, local words); }
naturalSet = RuleSet {
	rule "$h::SubThousand" { return local h; },
	rule "$h::SubThousand $m::Illion?" { return local h * local m; },
	rule "$h::SubThousand $m::Illion? and $n::SubHundred" { return local h * local m + local n; },
	rule "$h::SubThousand $m::Illion? $n::Natural" { return local h * local m + local n; },
	rule "$m::Illion? $n::Natural" { return local m + local n; }
} | illionSet;

// Convert words to an integer value.
function Integer(words) { return global wordSet(global integerSet, local words); }
integerSet = RuleSet {
	rule "$n::Natural" { return local n; },
	rule("negative $n::Natural", "minus $n::Natural") { return -(local n); }
};

//--------------------------------------------------------------------------------------------------

global sayNums = HashMap {
	0L=null, 1L="one", 2L="two", 3L="three", 4L="four",
	5L="five", 6L="six", 7L="seven", 8L="eight", 9L="nine",
	10L="ten", 11L="eleven", 12L="twelve", 13L="thirteen",
	14L="fourteen", 15L="fifteen", 16L="sixteen", 17L="seventeen",
	18L="eighteen", 19L="nineteen", 20L="twenty", 30L="thirty",
	40L="fourty", 50L="fifty", 60L="sixty", 70L="seventy", 80L="eighty",
	90L="ninety"
};

global powersOfThousand = list {
	null, "thousand", "million", "billion", "trillion",
	"quadrillion", "quintillion", "sextillion",
	"septillion", "octillion", "nonillion",
	"decillion", "undecillion", "dodecillion",
	"tredecillion", "quattuordecillion", "quinquadecillion",
	"sexdecillion", "septdecillion", "octdecillion",
	"novendecillion", "vigintillion"
};

// Convert a long integer to words.
function numToWords(n) {
	local neg = list{};
	if(local n < 0) { local n = const abs(n); local neg = list{"negative"}; }
	local n = long(n);
	local result = list{};
	try{
		local thousands = global powersOfThousand;
		if(n==0) { return "zero"; }
		while(local n) {
			local th = null;
			if(! local thousands) {
				return str(n) + " " + join(" ", const concat(local neg, local result));
			}
			else{ local th = local thousands[0]; local thousands <<= 1; }
			local abc = local n%1000L;
			local n = long(local n / 1000L);
			local a = long(local abc / 100L);
			local b = local abc % 100L;
			local b = local b<20 ? local b : local b - local b % 10L;
			local c = local b<20 ? 0L : local abc % 10L;
			local a = global sayNums[local a];
			local b = global sayNums[local b];
			local c = global sayNums[local c];
			if(local a || local b || local c) {
				local temp = list{};
				if(local a) { local temp = list{a, "hundred"}; }
				if(local b || local c) {
					if(local a) { local temp = const concat(local temp, "and"); }
					if(local b) {
						local temp = const concat(local temp, local c ? local b+"-"+local c : local b);
					}
					else if(local c) { local temp = const concat(local temp, local c); }
				}
				if(local th) { local result = const concat(local th, local result); }
				local result = const concat(local temp, local result);
			}
		}
		return const join(" ", const concat(local neg, local result));
	}
	else{ const println("numToWords(", local n, ") backtracked"); }
	catch err{ const println(local err); }
}

//--------------------------------------------------------------------------------------------------

// Convert to words from a number expressed as a string of digits (a numeral).
rule("say $i::Numeral", "speak $i::Numeral") {
	global no_match = false;
	try{
		global last_result = global numToWords(local i);
		const println(global last_result);
	}
	catch err{ println(err); }
}

// Convert the previous result:
// if it was an integer converted from words, convert it back to words.
// If it was words converted from an integer, convert it back to an integer.
rule("say last", "say it", "speak last", "speak it", "convert", "convert it", "convert last") {
	global no_match = false;
	try{
		local t = typeof(global last_result);
		if(t==Long || t==Int || t==Word) {
			global last_result = global numToWords(global last_result);
			const println(global last_result);
		}
		else if(typeof(global last_result) == String) {
			local last_result = global last_result;
			try{ global last_result = global interactiveWordsToNum(const tokenize(global last_result)); }
			else{ const println("couldn't convert to an integer, the words: ", global last_result); }
		}
		else{ const println("There is no previous result, we haven't done anything yet."); }
	}
	else{ const println("what?"); }
	catch err{ const println(err); }
}

// Display the previous result.
rule("last", "it") {
	global no_match = false;
	if(const defined(global last_result) && global last_result != null) { const println(global last_result); }
	else{ const println("There is no previous result, we haven't done anything yet."); }
}

// This is an interactive function that performs an Integer() conversion and prints out the results.
function interactiveWordsToNum(words) {
	try{
		local words = global splitNumberWords(local words);
		if(global DEBUG) { const println("split number words: ", local words); }
		if(words.fst) {
			global last_result = global Integer(local words.fst);
			const println(global last_result , " ", const join("", words.snd));
			global no_match = false;
			return global last_result;
		}
	}
	catch err{ const println(local err); }
}

// Call "interactiveWordsToNum()", converts wors to an integer value and displays the result.
rule "$x" { global interactiveWordsToNum(local x); }

//--------------------------------------------------------------------------------------------------

global last_result = null;

END{
	if(global no_match) { println("what?"); }
	for err in self.errors { println(local err); }
}

