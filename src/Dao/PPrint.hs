-- "src/Dao/PPrint.hs"  a pretty-printer designed especially for
-- printing Dao script code.
-- 
-- Copyright (C) 2008-2013  Ramin Honary.
-- This file is part of the Dao System.
--
-- The Dao System is free software: you can redistribute it and/or
-- modify it under the terms of the GNU General Public License as
-- published by the Free Software Foundation, either version 3 of the
-- License, or (at your option) any later version.
-- 
-- The Dao System is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-- GNU General Public License for more details.
-- 
-- You should have received a copy of the GNU General Public License
-- along with this program (see the file called "LICENSE"). If not, see
-- <http://www.gnu.org/licenses/agpl.html>.

{-# LANGUAGE TypeSynonymInstances #-}
{-# LANGUAGE FlexibleInstances #-}

module Dao.PPrint where

import           Dao.String

import           Control.Monad
import           Control.Monad.State

import           Data.List
import           Data.Char
import           Data.Monoid

----------------------------------------------------------------------------------------------------

-- | Remove trailing whitespace, I stole the idea from the Perl language.
chomp :: String -> String
chomp = foldl (\ out (spc, str) -> if null str then "" else out++spc++str) "" . spcstr where
  spcstr cx
    | null   cx = []
    | otherwise = 
         let (spc, more) = span  isSpace cx
             (str, cx  ) = break isSpace more
         in  (spc, str ) : spcstr cx

----------------------------------------------------------------------------------------------------

-- | The intermediate printer structure, the 'PPrint' monad generates a structure using this data
-- type, the pretty printer uses these types to make decisions on how to output information.
data PPrintItem
  = PNewLine -- ^ force a new line
  | PSoftLine -- ^ indicate a good place to break a line, but only if it doesn't fit on one line.
  | PPrintString  { pPrintString :: UStr } -- ^ a single string of output
  | PPrintIndent   { pPrintItems :: [PPrintItem] } -- ^ print each item on it's own line
    -- ^ a list items, one item per line of output
  | PPrintInline  { pPrintItems :: [PPrintItem] }
    -- ^ print items all on a single line of output, no wrapping
  | PPrintList    { pPrintSep :: UStr, pPrintItems :: [PPrintItem] }
    -- ^ a list of items separated by a separator string, as many items are written per line as
    -- possible, items wrap on the next line if they exceed the line limit.
  | PPrintClosure { pPrintOpen :: UStr, pPrintClose  :: UStr, pPrintItems  :: [PPrintItem] }
    -- ^ a list of items between an opening and closing string, possibly all on the same line of
    -- output.

-- | The state used by the 'PPrint' monad.
newtype PPrintState
  = PPrintState
    { pPrintStack :: [PPrintItem]
      -- ^ retrieves the stack of 'PPrintItem's generated during evaluation of 'PPrint' monadic
      -- functions.
    }

-- | Initialize the pretty printer monad, can be passed as the second argument to
-- 'Control.Monad.State.runState' and 'Control.Monad.State.execState'.
initPPrintState :: PPrintState
initPPrintState = PPrintState{ pPrintStack = [] }

instance Monoid PPrintState where
  mempty      = initPPrintState
  mappend a b = PPrintState{ pPrintStack = mappend (pPrintStack a) (pPrintStack b) }

-- | Evaluate a 'PPrint' monadic function to it's intermediate 'PPrintState'.
pEvalState :: PPrint () -> PPrintState
pEvalState fn = execState fn initPPrintState

instance Show PPrintState where { show = showPPrintState 80 "    " }
instance Show (PPrint ()) where { show p = show (execState p initPPrintState) }

----------------------------------------------------------------------------------------------------

class PPrintable a where { pPrint :: a -> PPrint () }

-- | A 'Control.Monad.State.State'ful pretty printer monad.
type PPrint a = State PPrintState a

-- not for export. Places a 'PPrintItem' onto the stack within the 'PPrintState'.
pPush :: PPrintItem -> PPrint ()
pPush item = modify (\p -> p{ pPrintStack = pPrintStack p ++ [item] })

-- not for export. Evaluates a 'PPrint' monad and returns the stack of 'PPrintItem's that were
-- created during evaluation.
pEval :: PPrint () -> [PPrintItem]
pEval fn = pPrintStack (execState fn initPPrintState)

-- | Force a new line
pNewLine :: PPrint ()
pNewLine = pPush PNewLine

-- | Indicate a good place to break a line, but only if there is not enough room on a single line.
pSoftLine :: PPrint ()
pSoftLine = pPush PSoftLine

-- not for export. Given a 'PPrintItem' constructor, constructs a 'PPrintItem' from a list of items
-- generated by 'pEval'uating a given 'PPrint' function, and 'pPush'es the 'PPrintItem' onto the
-- stack.
pSubList :: ([PPrintItem] -> PPrintItem) -> PPrint () -> PPrint ()
pSubList construct fn = pPush (construct (pEval fn))

-- | Print a 'Dao.String.UStr' as a single line.
pUStr :: UStr -> PPrint ()
pUStr = pPush . PPrintString

-- | Print a 'Prelude.String' as a single line.
pString :: String -> PPrint ()
pString = pUStr . ustr

-- | Print any value that instantiates 'Prelude.Show'.
pShow :: Show a => a -> PPrint ()
pShow = pString . show

-- | Shortcut for @('pPrint' . 'Data.List.concat')@
pConcat :: [String] -> PPrint ()
pConcat = pString . concat

-- | Evaluate the following 'PPrint' monad where every line of output is indented.
pIndent :: PPrint () -> PPrint ()
pIndent = pSubList PPrintIndent

-- | Evaluate the 'PPrint' printer, and every line of output will be used as an item in a list, and
-- every item is separated by a given separator string.
pInline :: PPrint () -> PPrint ()
pInline = pSubList PPrintInline

-- | Like 'pInline' but places a separator string between each item.
pList :: String -> PPrint () -> PPrint ()
pList sep = pSubList (PPrintList (ustr sep))

pClosure :: String -> String -> PPrint () -> PPrint ()
pClosure open close = pSubList (PPrintClosure (ustr open) (ustr close))

-- | A commonly used pattern, for example "list {a, b, c}", could be constructed by passing to this
-- function @('pString' "list")@, then the open and close brackets, then @('pList' "," items)@.
pHeader :: PPrint () -> String -> String -> PPrint () -> PPrint ()
pHeader header opn clo middle =
  pInline (header >> pString opn) >> pIndent middle >> pNewLine >> pString clo

----------------------------------------------------------------------------------------------------

-- not for export
data Printer
  = Printer
    { printerTab :: Int -- how many indentation marks should preceed this line
    , printerCol :: Int -- how many non-indentation characters are in the buffer
    , printerOut :: [(Int, Int, String)] -- all lines before the current line in the buffer
    , printerBuf :: String -- buffers the current line
    }

initPrinter :: Printer
initPrinter =
  Printer
  { printerTab = 0
  , printerCol = 0
  , printerOut = []
  , printerBuf = ""
  }

printerOutputTripple :: Printer -> (Int, Int, String)
printerOutputTripple st = (printerTab st, printerCol st, printerBuf st)

instance Monoid Printer where
  mempty = initPrinter
  mappend origSt st =
    origSt
    { printerBuf = printerBuf st
    , printerCol = printerCol st
    , printerOut = printerOut origSt ++ printerOutputTripple origSt : printerOut st
    }

-- | A kind of pre-conversion, the 'PPrintState' is broken into a list of strings, each string
-- preceeded by it's indentation factor.
linesFromPPrintState :: Int -> PPrintState -> [(Int, String)]
linesFromPPrintState maxWidth ps = end (execState (loop (pPrintStack ps)) mempty) where
  loop px = case px of
    PPrintList sep qx     : px -> loop (intercalate [PPrintString sep] (map return qx) ++ px)
    PSoftLine             : [] -> return ()
    PSoftLine : PSoftLine : px -> loop (PSoftLine:px)
    p : PSoftLine : p'    : px -> do
      prin p
      st <- get
      let col  = printerCol st
          buf  = printerBuf st
          st'  = execState (prin p') (st{printerCol = 0, printerBuf = ""})
          col' = printerCol st'
          buf' = printerCol st'
      if null (printerOut st) && col+col' <= maxWidth
        then put (mappend st st')
        else put $ st{ printerBuf = printerBuf st'
                     , printerCol = printerCol st'
                     , printerOut = printerOut st ++ printerOutputTripple st : printerOut st'
                     }
      loop px
    p:px -> prin p >> loop px
  prin :: PPrintItem -> State Printer ()
  prin p = case p of
    PNewLine        -> newline
    PPrintString p  -> string (ulength p) (uchars p)
    PPrintIndent  px -> do
      origSt <- setupBacktrack
      setIndent (+1)
      forM_ px (\p -> prin p >> noDupNewline)
      st <- get
      let minlines col buf ax = case ax of
            []               -> Just (col, buf)
            (_, len, str):ax ->
              let newlen = len+col
              in if newlen>maxWidth then Nothing else minlines newlen (buf++str) ax
      case minlines (printerCol origSt) (printerBuf origSt) (printerOut st) of
        Nothing         -> put $ mappend origSt st
        Just (col, buf) -> put $ origSt{ printerBuf = buf, printerCol = col }
      setIndent (\x -> x-1)
    PPrintInline px -> do
      origSt <- setupBacktrack
      forM_ px prin
      st <- get
      let len = printerCol st + printerCol origSt
      if len > maxWidth -- put all the text into the 'origSt' buffer,
        then  put $ mappend origSt st
        else  put $ origSt -- or else put all the text into the 'origSt' buffer
                    { printerBuf = printerBuf origSt ++ printerBuf st
                    , printerTab = len
                    }
    PPrintClosure opn clo px -> do
      setIndent (+1) >> string (ulength opn) (uchars opn)
      forM_ px (\p -> prin p >> softNewline)
      setIndent (\x -> x-1) >> string (ulength clo) (uchars clo)
  string len p = do
    st <- get
    if printerCol st + len > maxWidth then newline else return ()
    put $ st{ printerCol = printerCol st + len
            , printerBuf = printerBuf st ++ p
            }
  setIndent f = modify $ \st -> st{ printerTab = f (printerTab st) }
  setupBacktrack = do
    origSt <- get
    put (origSt{ printerCol = 0, printerBuf = [] })
    return origSt
  noDupNewline = gets printerBuf >>= \buf -> if null buf then return () else newline
  softNewline  = gets printerCol >>= \col -> if col>maxWidth then newline else return ()
  newline = modify $ \st ->
    st{ printerCol = 0
      , printerBuf = ""
      , printerOut = printerOut st ++ [(printerTab st, printerCol st, printerBuf st)]
      }
  end = map (\ (a, _, b) -> (a, chomp b)) . printerOut

-- | Given a list of strings, each prefixed with an indentation count, and an indentation string,
-- concatenate all strings into a one big string, with each string being indented and on it's own
-- line.
linesToString :: String -> [(Int, String)] -> String
linesToString indentStr = concatMap $ \ (indentCount, string) ->
  concat (replicate indentCount indentStr) ++ string ++ "\n"

-- Given an indentation string and a maximum width value, construct a string from the 'PPrintState'.
-- The maximum width value is used to call 'linesFromPPrintState', and the indentation string is
-- used to call 'linesToString'.
showPPrintState :: Int -> String -> PPrintState -> String
showPPrintState maxWidth indentStr ps = linesToString indentStr (linesFromPPrintState maxWidth ps)

