rule "match $X" {
	println("match $X --> x = ", x); return true;
}

rule "overlap $X" {
	println("overlap $X (1) --> x = ", x); return true;
}

rule "overlap $X" {
	println("overlap $X (2) --> x = ", x); return true;
}

rule("shared $X", "shared $X") {
	println("shared $X --> x = ", x); return true;
}

rule("first disjoint $X", "second disjoint $X") {
	println("(first/second) disjoint $x --> x = ", x); return true;
}

rule("multi $X", "multi $X") {
	println("multi $X (1) --> x = ", x); return true;
}

rule("multi $X", "multi $X") {
	println("multi $X (2) --> x = ", x); return true;
}

func test(str) {
	result = doAll(str);
	println("doAll() returned ", join(" ", result));
}

//: match $X --> x = hello
//: doAll() returned true
test("match hello");

//: match $X --> x = one two three
//: doAll() returned true
test("match one two three");

//: overlap $X (1) --> x = hello
//: overlap $X (2) --> x = hello
//: doAll() returned true true
test("overlap hello");

//: overlap $X (1) --> x = one two three
//: overlap $X (2) --> x = one two three
//: doAll() returned true true
test("overlap one two three");

//: shared $X --> x = hello
//: shared $X --> x = hello
//: doAll() returned true true
test("shared hello");

//: shared $X --> x = one two three
//: shared $X --> x = one two three
//: doAll() returned true true
test("shared one two three");

//: (first/second) disjoint $x --> x = hello
//: doAll() returned true
test("first disjoint hello");

//: (first/second) disjoint $x --> x = hello
//: doAll() returned true
test("second disjoint hello");

//: (first/second) disjoint $x --> x = one two three
//: doAll() returned true
test("first disjoint one two three");

//: (first/second) disjoint $x --> x = one two three
//: doAll() returned true
test("second disjoint one two three");

//: multi $X (1) --> x = hello
//: multi $X (1) --> x = hello
//: multi $X (2) --> x = hello
//: multi $X (2) --> x = hello
//: doAll() returned true true true true
test("multi hello");

//: multi $X (1) --> x = one two three
//: multi $X (1) --> x = one two three
//: multi $X (2) --> x = one two three
//: multi $X (2) --> x = one two three
//: doAll() returned true true true true
test("multi one two three");

func testlocal() {
	rule "local rule" { println("local rule --> OK"); }
	result = doAll("local rule");
	println("local rule result = ", result);
}
//: local rule --> OK
//: local rule result = list { true }
testlocal();

func testRuleSet(msg, R, str) {
	println("testRuleSet ", msg, "...");
	try {
		result = doIn(R, str);
		println("doIn() returned ", result);
	}
	catch err { println("doIn() backtracked with ", err); }
	try {
		result = doInAll(R, str);
		println("doInAll() returned ", result);
	}
	catch err { println("doInAll() backtracked with", err); }
}

R1 = RuleSet {
	rule "hello" { println("R1 rule \"hello\" success"); return "hi"; },
	rule "my name is $name*." {
		println("R1 rule \"my name is $name.\" success");
		return join(" ", "Hi", name, "how are you?");
	}
};

R2 = RuleSet {
	rule "a b $C" { println("R2 rule \"a b $C\" success"); return C; },
	rule "a b c $D" { println("R2 rule \"a b c $D\" success"); return D; }
};

//: doIn() returned hi
//: doInAll() returned hi
testRuleSet("R1 \"hello\"", R1, "hello");

//: doIn() returned list { "Hi Computer how are you?" }
//: doInAll() returned list { "Hi Computer how are you?" }
testRuleSet("R2 \"my name is Computer\"", R1, "my name is Computer.");

//: doIn() returned list {
//:	    list { "d", " ", "e", " ", "f" }, list { "c", " ", "d", " ", "e", " ", "f" }
//: }
//: doInAll() returned list {
//:	    list { "d", " ", "e", " ", "f" }, list { "c", " ", "d", " ", "e", " ", "f" }
//: }
testRuleSet("R2 \"a b c d e f\"", R2, "a b c d e f");

//: doAllIn() returned list{}
testRuleSet("R1 with many non-matching items", R1, list{ "overlap x y z", "first disjoint X", "second disjoint X", "multi x y z" });

//: doAllIn() returned list{}
testRuleSet("R2 with many non-matching items", R2, list{ "overlap x y z", "first disjoint X", "second disjoint X", "multi x y z"});

R3 = R1 | R2;
println("\ntypeof(R1|R2) = ", typeof(R3), "\n");

//: doAllIn() returned list{}
try {
	testRuleSet("R1|R2 \"hello\", \"my name is computer\", \"a b c d e f\"", R3, "hello", "my name is Computer.", "a b c d e f");
}
catch err {
	msg = "";
	if(defined(err)) { msg = join("", ": ", err); }
	println("testRuleset R1|R2 failed", msg);
}

//: doAllIn() returned list{}
testRuleSet("R1|R2 with many non-matching items", R3, list{ "overlap x y z", "first disjoint X", "second disjoint X", "multi x y z"});

rule "my name is $X" {
	println("this.tokens = ", this.tokens);
	println("this.query  = ", this.query);
	println("join(\"\", this.tokens) = ", join("", this.tokens));
}
//: this.tokens = list { "my", " ", "name", " ", "is", " ", "Computer" }
//: this.query  = my name is Computer
//: join("", this.tokens)  = my name is Computer
doGlobal("my name is Computer");

p = "test$X pattern";
rule(p) { println("test-pattern: ", X); }

doGlobal("test one two three pattern");
doGlobal("test pattern");




