DEBUG = false;

BEGIN { global no_match = true; }

rule "show work" {
	global DEBUG = true; global no_match = false;
	println("will show how I compute the value");
}

rule("quiet", "silent", "silence", "dont show work") {
	global DEBUG = false; global no_match = false;
	println("will compute silently");
}

//--------------------------------------------------------------------------------------------------

debugIndent = list{};
function tab() { return join("->", debugIndent) + "->"; }
function indent(n) { debugIndent += list{n}; }
function unindent() { debugIndent >>= 1; }

END { if(DEBUG) { for err in self.errors { println(err); } } }

function digitOrRules($ruleset, n) {
	R = @ruleset;
	if(DEBUG) {
		println(tab(), ruleset, "(", n, ") //begin");
		indent(ruleset);
	}
	try {
		i = int(join("", n));
		if(DEBUG) {
			unindent();
			println(tab(), ruleset, "(", n, ") //returned ", i);
		}
		return i;
	}
	catch err {
		try {
			i = R.do(n);
			if(DEBUG) {
				unindent();
				println(tab(), ruleset, "(", n, ") //returned ", i);
			}
			return i;
		}
		else {
			unindent();
			if(DEBUG) {
				println(tab(), ruleset, "(", n, ") //backracked");
			}
		}
		catch err {
			if(DEBUG) {
				unindent();
				println(tab(), ruleset, "(", n, ") //failed\n", err);
			}
		}
	}
	throw;
}

digitWords = RuleSet {
	rule "zero"  { return 0; },
	rule "a"     { return 1; },
	rule "one"   { return 1; },
	rule "two"   { return 2; },
	rule "three" { return 3; },
	rule "four"  { return 4; },
	rule "five"  { return 5; },
	rule "six"   { return 6; },
	rule "seven" { return 7; },
	rule "eight" { return 8; },
	rule "nine"  { return 9; }
};

function digit(n) { return digitOrRules(digitWords, n); }

umpteenWords = RuleSet {
	rule "ten"       { return 10; },
	rule "eleven"    { return 11; },
	rule "twelve"    { return 12; },
	rule "thirteen"  { return 13; },
	rule "fourteen"  { return 14; },
	rule "fifteen"   { return 15; },
	rule "sixteen"   { return 16; },
	rule "seventeen" { return 17; },
	rule "eighteen"  { return 18; },
	rule "nineteen"  { return 19; }
};

function umpteen(n) { return digitOrRules(umpteenWords, n); }

umptyWords = RuleSet {
	rule "twenty"  { return 20; },
	rule "thirty"  { return 30; },
	rule "fourty"  { return 40; },
	rule "fifty"   { return 50; },
	rule "sixty"   { return 60; },
	rule "seventy" { return 70; },
	rule "eighty"  { return 80; },
	rule "ninety"  { return 90; }
};

function umpty(n) { return digitOrRules(umptyWords, n); }

umptyPlusWords = RuleSet {
	rule "$d::digit"           { return d; },
	rule "$n::umpteen"         { return n; },
	rule "$n::umpty"           { return n; },
	rule "$n::umpty-$d::digit" { return n+d; },
	rule "$n::umpty $d::digit" { return n+d; }
};

function umptyPlus(n) { return digitOrRules(umptyPlusWords, n); }

hundredsWords = RuleSet {
	rule "$d::umptyPlus"                           { return d; },
	rule "hundred"                                 { return 100; },
	rule "$d::umptyPlus hundred"                   { return 100*d; },
	rule "$d::umptyPlus hundred $n::umptyPlus"     { return 100*d + n; },
	rule "$d::umptyPlus hundred and $n::umptyPlus" { return 100*d + n; }
};

function hundreds(n) { return digitOrRules(hundredsWords, n); }

illionWords = RuleSet {
	rule "thousand"          { return 10**3; },
	rule "million"           { return 10**6; },
	rule "billion"           { return 10**9; },
	rule "trillion"          { return 10**12; },
	rule "quadrillion"       { return 10**15; },
	rule "quintillion"       { return 10**18; },
	rule "sextillion"        { return 10**21; },
	rule "septillion"        { return 10**24; },
	rule "octillion"         { return 10L**27; },
	rule "nonillion"         { return 10L**30; },
	rule "decillion"         { return 10L**33; },
	rule "undecillion"       { return 10L**36; },
	rule "dodecillion"       { return 10L**39; },
	rule "tredecillion"      { return 10L**42; },
	rule "quattuordecillion" { return 10L**45; },
	rule "quinquadecillion"  { return 10L**48; },
	rule "sexdecillion"      { return 10L**51; },
	rule "septdecillion"     { return 10L**54; },
	rule "octdecillion"      { return 10L**57; },
	rule "novendecillion"    { return 10L**60; },
	rule "vigintillion"      { return 10L**63; }
};

function illion(n) { return digitOrRules(illionWords, n); }

bigNumWords = RuleSet {
	rule "$h::hundreds"                       { return h; },
	rule "$m::illion"                         { return m; },
	rule "$h::hundreds $m::illion"            { return h*m; },
	rule "$h::hundreds $m::illion $n::bignum" { return h*m + n; }
};

function bignum(n) { return digitOrRules(bigNumWords, n); }

function number(n) {
	try{ return int(join("", n)); } else{} catch err {}
	return bignum(n);
}

//--------------------------------------------------------------------------------------------------
rule "$n::number" {
	println(n); global no_match = false;
}

rule "$x" { if(no_match) { println("no match for: ", x); } }

