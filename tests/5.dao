rule "match $X" {
	println("match $X --> X = ", X); return true;
}

rule "overlap $X" {
	println("overlap $X (1) --> X = ", X); return true;
}

rule "overlap $X" {
	println("overlap $X (2) --> X = ", X); return true;
}

rule("shared $X", "shared $X") {
	println("shared $X --> X = ", X); return true;
}

rule("first disjoint $X", "second disjoint $X") {
	println("(first/second) disjoint $X --> X = ", X); return true;
}

rule("multi $X", "multi $X") {
	println("multi $X (1) --> X = ", X); return true;
}

rule("multi $X", "multi $X") {
	println("multi $X (2) --> X = ", X); return true;
}

func test(str) {
	try {
		result = doAll(str);
		println("doAll(\"", str, "\") returned ", result);
	}
	else { println("nothing matched string: ", str); }
	catch err { println(err); }
}

END {
	i = 0;
	for err in self.errors { println(i, ": ", err); i = i+1; }
}

//: match $X --> X = hello
//: doAll("match hello") returned list { true }
test("match hello");

//: match $X --> X = one two three
//: doAll("match one two three") returned list { true }
test("match one two three");

//: overlap $X (1) --> X = hello
//: overlap $X (2) --> X = hello
//: doAll("overlap hello") returned true list { true }
test("overlap hello");

//: overlap $X (1) --> X = one two three
//: overlap $X (2) --> X = one two three
//: doAll("overlap one two three") returned list { true, true }
test("overlap one two three");

//: shared $X --> X = hello
//: shared $X --> X = hello
//: doAll() returned true true
test("shared hello");

//: shared $X --> X = one two three
//: shared $X --> X = one two three
//: doAll() returned true true
test("shared one two three");

//: (first/second) disjoint $X --> X = hello
//: doAll() returned true
test("first disjoint hello");

//: (first/second) disjoint $X --> X = hello
//: doAll() returned true
test("second disjoint hello");

//: (first/second) disjoint $X --> X = one two three
//: doAll() returned true
test("first disjoint one two three");

//: (first/second) disjoint $X --> X = one two three
//: doAll() returned true
test("second disjoint one two three");

//: multi $X (1) --> X = hello
//: multi $X (1) --> X = hello
//: multi $X (2) --> X = hello
//: multi $X (2) --> X = hello
//: doAll() returned true true true true
test("multi hello");

//: multi $X (1) --> X = one two three
//: multi $X (1) --> X = one two three
//: multi $X (2) --> X = one two three
//: multi $X (2) --> X = one two three
//: doAll() returned true true true true
test("multi one two three");

func testlocal() {
	rule "local rule" { println("local rule --> OK"); }
	result = doAll("local rule");
	println("local rule result = ", result);
}
//: local rule --> OK
//: local rule result = list { true }
testlocal();

func testRuleSet(msg, R, str) {
	println("testRuleSet ", msg, "...");
	try {
		a = R.do(str);
		println("R.do(\"", str, "\") returned ", a);
	}
	else { println("R.do(\"", str, "\") backtracked"); }
	catch err { println("R.do(\"", str, "\") failed with ", err); }
	try {
		a = R.doAll(str);
		println("R.doAll(\"", str, "\") returned ", a);
	}
	else { println("R.doAll(\"", str, "\") backtracked"); }
	catch err { println("R.doAll(\"", str, "\") failed with ", err); }
}

R1 = RuleSet {
	rule "hello" { println("R1 rule \"hello\" success"); return "hi"; },
	rule "my name is $name*." {
		println("R1 rule \"my name is $name.\" success");
		return join(" ", "Hi", name, "how are you?");
	}
};

R2 = RuleSet {
	rule "a b $C" { println("R2 rule \"a b $C\" success"); return C; },
	rule "a b c $D" { println("R2 rule \"a b c $D\" success"); return D; }
};

//: doIn() returned hi
//: doInAll() returned hi
testRuleSet("R1 \"hello\"", R1, "hello");

//: doIn() returned list { "Hi Computer how are you?" }
//: doInAll() returned list { "Hi Computer how are you?" }
testRuleSet("R1 \"my name is Computer\"", R1, "my name is Computer.");

//: R.do() returned list {
//:	    list { "d", " ", "e", " ", "f" }, list { "c", " ", "d", " ", "e", " ", "f" }
//: }
//: R.doAll() returned list {
//:	    list { "d", " ", "e", " ", "f" }, list { "c", " ", "d", " ", "e", " ", "f" }
//: }
testRuleSet("R2 \"a b c d e f\"", R2, "a b c d e f");

//: R.doAll() returned list{}
testRuleSet("R1 with many non-matching items", R1, list{ "overlap x y z", "first disjoint X", "second disjoint X", "multi x y z" });

//: R.doAll() returned list{}
testRuleSet("R2 with many non-matching items", R2, list{ "overlap x y z", "first disjoint X", "second disjoint X", "multi x y z"});

R3 = R1 | R2;
println("\ntypeof(R1|R2) = ", typeof(R3), "\n");

//: R.doAll() returned list{}
try {
	testRuleSet("R1|R2 \"hello\", \"my name is computer\", \"a b c d e f\"", R3, list{"hello", "my name is Computer.", "a b c d e f"});
}
catch err {
	msg = "failed";
	if(defined(err)) { msg = join("", "failed: ", err); }
	println("testRuleset R1|R2 ", msg);
}

//: R.doAll() returned list{}
testRuleSet("R1|R2 with many non-matching items", R3, list{"overlap x y z", "first disjoint X", "second disjoint X", "multi x y z"});

rule "my name is $X" {
	println("self.tokens = ", self.tokens);
	println("join(\"\", self.tokens) = ", join("", self.tokens));
}
//: self.tokens = list { "my", " ", "name", " ", "is", " ", "Computer" }
//: join("", self.tokens)  = my name is Computer
doGlobal("my name is Computer");

p = "test$X pattern";
rule(p) { println("test-pattern: ", X); }

doGlobal("test one two three pattern");
doGlobal("test pattern");

